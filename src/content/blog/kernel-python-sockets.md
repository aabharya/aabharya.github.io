---
author: Ali Abharya
pubDatetime: 2025-07-10T16:38:17.169Z
modDatetime: 2025-07-10T16:28:17.169Z
title: سوکت‌ها در سطح کرنل و پایتون
title_seo: Socket API in Kernel and Python
slug: socket-api
featured: true
draft: false
tags:
  - socket
  - tcp
  - kernel
  - python
  - http

description: سوکت‌ها در سطح کرنل و پایتون
---

# سوکت‌ها در سطح کرنل و پایتون

از چند روز پیش که دور دوم مطالعه کتاب **HTTP: The Definitive Guide** رو شروع کردم یاد جمله حسین‌ناصر افتادم که میگه:

> من با هیچ ابزاری کار نمی‌کنم مگر اینکه ۱۰۰ درصد جزییات داخلیش رو عمیقا درک کرده باشم.

همین شد که به بخش سوکت‌ها که رسیدیم تصمیم گرفتم یکبار دستور اجرای سرور HTTP و همینطور هندل کردن یک درخواست HTTP رو توی پایتون دیباگ کنم. هدفم هم این بود internal کتابخونه استاندارد پایتون و همینطور اینترفیس WSGI رو بیشتر درک کنم به علاوه برام جالب بود که بدونم از سمت سیستم عامل هم این وسط چه اتفاقاتی میوفته؟

![http_dfg](@assets/images/http_dfg.jpeg)

خیلی خلاصه بخوام بگم اون بازیگر اصلی این وسط یه مفهومی هست به نام سوکت که هم سیستم‌عامل و هم کتابخونه استاندارد پایتون یه API برای اون دارن و در حقیقت اون چرخه request - response بین کلاینت و سرور از طریق همین سوکت هندل میشه.

این نوشته دو بخش داره:‌

- اول اینکه سوکت چی هست و در سطح کرنل چه عملیاتی میشه باهاش انجام داد؟

- دوم اینکه وقتی تو پایتون یه سرور HTTP اجرا می‌کنیم و یک درخواست از سمت کلاینت میاد تا پاسخ رو دریافت کنه چه فراخوانی‌هایی در پایتون انجام میشه و به تبع اون‌ها چه فراخوانی‌های سیستمی در سطح کرنل انجام میشه؟

---

## سوکت در سطح سیستم‌عامل

### 1️⃣ سوکت چی هست؟!

در سطح سیستم‌عامل، سوکت رو میشه شبیه یک فایل در نظر گرفت که میشه روی اون عملیات خواندن و نوشتن انجام داد. وقتی یک سرور اجرا میشه کرنل ابتدا یک سوکت شنونده `(Listening Socket)` ایجاد می‌کنه که روی یک آدرس IP و پورت خاص (مثلاً 0.0.0.0:8000) آماده دریافت درخواست‌هاست.

این سوکت صرفاً مسئول دریافت درخواست‌های اتصال `(SYN)` هست و دادهٔ واقعی را منتقل نمی‌کنه. به محض اینکه کلاینت درخواست اتصال میده، کرنل سیستم‌عامل یک سوکت جدید به نام سوکت اتصال `(Connection Socket)` می‌سازه که مختص همون کلاینت است. بنابراین هر کلاینت سوکت مستقل خودش یا `File Descriptor` خودش رو داره و داده‌هایش با سایر کلاینت‌ها تداخل پیدا نمی‌کنه.

---

### 2️⃣ عملیات قابل انجام با سوکت در سطح کرنل

در چرخه درخواست پاسخ بین کلاینت و سرور bind، listen و accept سه عملیات اصلی در این فرآیند هستند. در جدول زیر همه عملیات قابل انجام توسط API سوکت در سطح کرنل خلاصه شده‌اند:

| API سوکت در سطح کرنل | توضیحات                                            |
| -------------------- | -------------------------------------------------- |
| socket               | ایجاد یک سوکت جدید بدون نام و بدون اتصال           |
| bind                 | اختصاص یک شماره پورت و اینترفیس به سوکت            |
| connect              | ایجاد یک اتصال TCP به سوکت و یک host و پورت remote |
| listen               | تغییر وضعیت سوکت برای دریافت درخواست               |
| accept               | منتظر ماندن برای ایجاد یک اتصال به پورت            |
| read                 | خواندن n بایت از سوکت به داخل بافر                 |
| write                | نوشتن n بایت از بافر به داخل سوکت                  |
| close                | بستن کامل اتصال TCP                                |
| shutdown             | بستن فقط ورودی یا خروجی اتصال TCP                  |
| getsockopt           | خواندن مقدار یک پیکربندی داخلی سوکت                |
| setsockopt           | تغییر مقدار یک پیکربندی داخلی سوکت                 |

---

## سوکت در سطح کتابخانه استاندارد پایتون

### 1️⃣ عملیات قابل انجام با سوکت در سطح پایتون

| API سوکت در سطح پایتون | توضیحات  |
| ---------------------- | -------- |
| ???                    | جای خالی |

---

### 2️⃣ فراخوانی‌های سمت پایتون در زمان راه‌اندازی سرور

جای خالی

---

### 3️⃣ فراخوانی‌های سمت پایتون در زمان پاسخ به درخواست

جای خالی

---

## جمع‌بندی

درک جزئیات و فهم عمیق ابزارها و طریقه استفاده از اون‌ها دغدغه همیشگی یک **مهندس نرم‌افزار** هست. وقتی یک مفهوم را تا سطح عملکرد داخلی‌اش می‌شناسیم، ذهن ما می‌تونه اون را در یک چارچوب منطقی دسته‌بندی کنه: علت‌ها، فرآیندها و پیامدها.
اما اگه این لایه‌های زیرین ابزارها رو درک نکنیم در ارائه راه‌حل‌ها در نهایت وابستگی زیادی به فریمورک‌ها پیدا می‌کنیم و به اصطلاح نمی‌تونیم `out of the box` فکر کنیم چون اجازه دادیم فریمورک‌ها این جزییات رو از ما مخفی کنن و به جای ما فکر کنن و تصمیم بگیرند.
